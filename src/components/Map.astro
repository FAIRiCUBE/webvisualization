

<div id="map"></div>

<script>
import 'ol/ol.css';
import * as ol from 'ol';
import TileLayer from 'ol/layer/WebGLTile';
import {getGeotiffMinmaxFromAuxXML} from '../scripts/getGeotiffMinmaxFromAuxXML.js';
import type {Extent} from 'ol/extent';

import OldTileLayer from 'ol/layer/Tile';
import GeoTIFF from 'ol/source/GeoTIFF';
import OSM from 'ol/source/OSM';
import { getInterpolateBand1AsColor } from '../scripts/palette.js';
import { transformExtent, Projection, get as getProjection, fromLonLat } from 'ol/proj';
import {register,fromEPSGCode} from 'ol/proj/proj4';
import STAC from 'ol-stac';
import proj4 from 'proj4'
import * as d3 from 'd3';

let source : any = null;
let layer : TileLayer | null = null;
let flag_styleIsSet = false; // This is used to prevent setting the style multiple times

// Register EPSG:3035
//proj4.defs("EPSG:3035","+proj=laea +lat_0=52 +lon_0=10 +x_0=4321000 +y_0=3210000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs +type=crs");
proj4.defs("EPSG:31256","+proj=tmerc +lat_0=0 +lon_0=16.3333333333333 +k=1 +x_0=0 +y_0=-5000000 +ellps=bessel +towgs84=551.7,162.9,467.9,6.04,1.96,-11.38,-4.82 +units=m +no_defs +type=crs");

register(proj4); // Make projections defined in proj4 (with proj4.defs()) available in OpenLayers. Req

const baselayer = new OldTileLayer({source:new OSM()});
const googleview = new ol.View({
  projection: 'EPSG:3857',
  //center: [16.2,48.2],zoom:10 // Vienna
  //center: [10,55.2],zoom:6 // Copenhagen
  //center:[-77.1778,26.4858], zoom: 8 // Virgin Gorda
});
/*googleview.setCenter( fromLonLat([-77.1778,26.4858], googleview.getProjection())); googleview.setZoom(8);  // Virgin Gorda
googleview.setCenter( fromLonLat([-10,55.2], googleview.getProjection())); googleview.setZoom(6);  // Copenhagen
googleview.setCenter( fromLonLat([16.2,48.2], googleview.getProjection())); googleview.setZoom(10);  // Vienna
*/

const map = new ol.Map({
      target: 'map',
      layers: [baselayer]//,
      //view: googleview //source.getView()
    });


async function buildMapForGeotiff() {

  // Which GeoTIFF to load?
  let url = localStorage.getItem('url');

  //url = 'https://data.sustainability.nilu.no/ua2018_mosaic_raster_10m_cog_2_3_B1.tif';
  //url = 'https://data.sustainability.nilu.no/ua2018_mosaic_raster_10m_cog_1_1_B1.tif';


  if (!url) {
    console.error(`No URL in localStorage`);
    return;
  }

  url = url.replace('https://fairicube.s3.eu-central-1.amazonaws.com/vienna_data/100m/r04_imp/','https://data.sustainability.nilu.no/fairicube/');
  url = url.replace('https://fairicube.s3.eu-central-1.amazonaws.com/vienna_data/100m/r05_treecover/','https://data.sustainability.nilu.no/fairicube/');
  
  //@ts-ignore
  window.newToast(`Loading ${url}`);

  //If url does not start with "http"then add the curent location base url (server url)
  if (!url.startsWith("http")) url = window.location.origin + url;

  // If URL does not end with .tif, then return
  if (!url.endsWith('.tif')) {
    window.newToast({title: 'Error', message: `URL ${url} does not end with .tif`});
    return;
  }

  // This style flag is used to prevent setting the style multiple times
  // When we build a fresh map we can reset this flag
  flag_styleIsSet = false;

  const geotiffSource : any = {url};

  // Try to fetch and parse an {url}.aux.xml file. The file is an XML file with metadata about the GeoTIFF
  const minmax = await getGeotiffMinmaxFromAuxXML(url);
  if (minmax) {
    geotiffSource.min = minmax[0];
    geotiffSource.max = minmax[1];
    console.log(`Used .tif.aux.xml to find min=${geotiffSource.min}, max=${geotiffSource.max}`);
  }


  // Create the source and layer

  source = new GeoTIFF({sources: [geotiffSource], normalize: true});
  layer = new TileLayer({source});


  // Set timeout for 5 seconds. If flag_styleIsSet false at that time, print a warning to console that we haven't loaded any tiles.
  setTimeout(() => {
    if (!flag_styleIsSet) window.newToast({title: 'Error', message: `After 5s, no tiles have been loaded...`});
  }, 5000);

  // Callback on tile load. This is used to set the style
  source.on('tileloadend', (event) => {

    if (flag_styleIsSet) return; // If the style has already been set, do nothing

    window.newToast({title: 'Info', message: `Got image with ${event.target.bandCount} bands`});
    if (layer) (layer as TileLayer).setStyle(getInterpolateBand1AsColor()); // Set the style

    flag_styleIsSet = true; // Set the flag
  });


  // Create the map
  map.setLayers([baselayer,layer]);
  map.render();

/*
  const vo = await source.getView();
  if (!vo.projection) {
    console.log(`File  ${url} contains insufficient metadata about its projection`);
    //return;
  }

  const proj = getProjection(vo.projection?.getCode());
  if (!proj) {
    // Look up at epsg.io
    vo.projection= await fromEPSGCode(vo.projection?.getCode());
    console.log(`Downloading projection ${vo.projection.getCode()} used by ${url}`);
    //return;
  }

  // Reproject the extent to the map's projection
  const extent = transformExtent(vo.extent, vo.projection, googleview.getProjection());
  map.getView().fit(extent);
*/

}; // function buildMapforGeotiff








async function buildMapForSTACItem() {

// Which STAC item to load?
let stac_json = localStorage.getItem('stac');


if (!stac_json) {
  console.error(`No STAC JSON in localStorage`);
  return;
}

const layer = new STAC({url: stac_json});


// Try to fetch and parse an {url}.aux.xml file. The file is an XML file with metadata about the GeoTIFF
/*const minmax = await getGeotiffMinmaxFromAuxXML(url);
if (minmax) {
  geotiffSource.min = minmax[0];
  geotiffSource.max = minmax[1];
  console.log(`Used .tif.aux.xml to find min=${geotiffSource.min}, max=${geotiffSource.max}`);
}
*/



layer.on('sourceready', () => {
  const view = map.getView();
  view.fit(layer.getExtent() as Extent);

});

layer.on('assetsready', () => {
  // Assign titles for e.g. a layerswitcher
  for (const sublayer of layer.getLayersArray()) {
    const stac = sublayer.get('stac');
    let title;
    if (stac.isAsset() || stac.isLink()) {
      title = stac.getMetadata('title') || stac.getKey();
    } else {

      const firstDataAsset = stac.getAssets().find(d=>d.roles.includes("data"));
      if (firstDataAsset) {
        localStorage.setItem('url', firstDataAsset.href);
        buildMapForGeotiff();
      } else {
        console.error(`No asset with role "data" found in ${stac_json}`);
      }

    }

    sublayer.set('title', title);
  }
});



// Create the map
map.setLayers([baselayer,layer]);
map.render();


}; // function buildMapForSTACItem









buildMapForSTACItem(); // Execute this on page load

// Add a listener for the "newsource" event
document.addEventListener('newsource', buildMapForSTACItem);




// https://sentinel-cogs.s3.us-west-2.amazonaws.com/sentinel-s2-l2a-cogs/21/H/UB/2021/9/S2B_21HUB_20210915_0_L2A/TCI.tif


</script>

<style>
#map {
  position: absolute;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
}
</style>